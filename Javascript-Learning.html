<!DOCTYPE html>
<html lang="en">
<head>
  <title>JavaScript Notes</title>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<style>
  table, th, td {
    border: 1px solid black;
    border-collapse: collapse;
    
  }

  
</style>
<body>
  
  
  <h1>VARIABLES</h1>
  <h4>What is a variable?</h4>

  <p>A variable is a container for a value. (Variables are containers for storing values.)</p>

  <h2>Declaring a Variable</h2>
  <p>Creating a variable in JavaScript is called "declaring" a variable.</p>

  <p>JavaScript variables can be declared in 4 ways:</p>

  <p>
    <li>Automatically</li>
    <li>Using var</li>
    <li>Using let</li>
    <li>Using const</li>
  </p>
  
  <h4>Automatically</h4>
  <b>Example:</b> In this first example x, y, and z are undeclared variables. They are automatically declared when first used:

  <pre>
    <code>
      x = 3;
      y = 4;
      z = x + y;
    </code>
  </pre>
  

  <p>From the examples you can guess:</p>

  <li>x stores the value 3</li>
  <li>y stores the value 4</li>
  <li>z stores the value 7</li>

  <h4>var</h4> 
  <p>
    The <code>var</code> keyword was used in all JavaScript code from 1995 to 2015.
  </p>
  <p>
    The <code>let</code> and <code>const</code> keywords were added to JavaScript in 2015.
  </p>

  <p>
    The var keyword should only be used in code written for older browsers.
  </p>

  <p>
    <b>Function-scoped</b> (limited to the function where it is declared).
  </p>
  

  

  <p>Can be redeclared and updated.</p>

  Hoisted -> JavaScript moves it to the top of its scope but initilizes it with <code>undefined</code>.

  <h4>let</h4>
  <p>Introduced in ES6 (2015).</p>

  <b>Block-scoped</b> (limited to <code>{ }</code> where it's declared).

  <p>Can be updated (re-assign) but not redeclared in the same scope.</p>

  <pre>
    <code>
      let age = 29;
      age = 30; //update allowed
      console.log(age) //30
    </code>
  </pre>

  <h4>const</h4>
  <p>Also introduced in ES6.</p>
  <p><b>Block-scoped</b> like <code>let</code>.</p>
  <p>Must be initialized when declared.</p>
  <p>Cannot be reassigned (constant).</p>
  <p>Good for values that shouldn't change.</p>

  
  <pre>
    <code>
      const birthYear = 1991;
      console.log(birthYear); //1991

      //birthYear = 2001; X Error: Assignment to constant variable
    </code>
  </pre>
  
  <p>
    <b>Note:</b> <code>const</code> does <b>not make objects immutable</b>. You can still change properties inside an object/array:
  </p>

  <pre>
    <code>
      const person = { name: "Nico" };
      person.name = "Velti"; // allowed
      console.log(person); // { name: "Velti" }
    </code>
  </pre>

  <h2>Initializing a Variable</h2>
  <p>Initializing a variable means assigning an initial value to a variable at the time it is declared or later, so it holds something instead of being <code>undefined</code>.</p>

  <p>- Declaration without initialization - When you just declare a variable without assigning a value, it will automatically hold the value undefined:</p>
  <pre>
    <code>
      let age; // declared but not initialized
      console.log(age); // undefined
    </code>
  </pre>

  <p>- Declaraiton with initialization - When you both declare and assign a value in one step:</p>
  <pre>
    <code>
      let age = 27; // declared + initialized
  console.log(age); // 27
    </code>
  </pre>

  

  <p>- Later initialization - You can also declare first, then initialize later:</p>
  <pre>
    <code>
      let name;  // declaration
      name = "John"; // initialization
      console.log(name); // John
    </code>
  </pre>

  
  

  <b>Initialization</b> is the process of giving a variable its first value.

  <h1>What are Data Types?</h1>

  <p>A data type tells JavaScript what kind of value a variable holds.<br>
  For example: <code>"Burak"</code> is text(string), <code>27</code> is a number, <code>true</code> is a boolean.</p>
 
  <p>JavaScript has two main categories of data types:</p>

  <h3>1. Primitive Data Types (simple, immutable)</h3>
  <p>Primitive means: stored directly in memory as a single value.<br>There are 7 primitive types:</p>

  <b>1. Number</b>
  <ul>
    <li>Represents both integers and floating-point numbers.</li>
    <li>Example:</li>
  </ul>
  <pre>
      <code>
        let age = 27;
        const pi = 3.14;
      </code>
  </pre>
  <b>2. String</b>
  <ul>
    <li>Represents text, written inside quotes.</li>
    <li>Example:</li>
  </ul>
  <pre>
      <code>
        let name = "Micheal";
        let city = "Yalova";
      </code>
  </pre>
  <b>3. Boolean</b>
  <ul>
    <li>Represents logical values <code>true</code> or <code>false</code></li>
    <li>Example:</li>
  </ul>
  <pre>
      <code>
        let isStudent = true;
        let hasCar = false;
      </code>
  </pre>
  <b>4. Undefined</b>
  <ul>
    <li>A variable declared but not initialized.</li>
    <li>Example:</li>
  </ul>
  <pre>
      <code>
        let x;
        console.log(x);  // undefined
      </code>
  </pre>
  <b>5. Null</b>
  <ul>
    <li>Represents intentional empty value.</li>
    <li>Example:</li>
  </ul>
  <pre>
      <code>
        let y = null;
      </code>
  </pre>
  <b>6. Symbol (ES6)</b>
  <ul>
    <li>Represents a unique identifier (often used in objects).</li>
    <li>Example:</li>
  </ul>
  <pre>
      <code>
        let id = symbol("id");
      </code>
  </pre>
  <b>7. BigInt (ES11 / 2020)</b>
  <ul>
    <li>For very large integers beyond <code>Number</code> limit.</li>
    <li>Example:</li>
  </ul>
  <pre>
      <code>
        let big = 123456789012345678901234567890n;
      </code>
  </pre>

  <h3>Non-Primitive (Reference) Data Types (complex, mutable)</h3>
  <p>These store references to memory, not the actual value.<br>Examples:</p>

  <b>1. Object</b>
  <ul>
    <li>Collection of key-value pairs.</li>
    <li>Example:</li>
  </ul>
  <pre>
    <code>
      let person = { name: "Tom", age: 36 };
    </code>
  </pre>

  <b>2. Array</b>
  <ul>
    <li>Ordered list of values.</li>
    <li>Example:</li>
  </ul>
  <pre>
    <code>
      let numbers = [1, 2, 3, 4, 5];
    </code>
  </pre>
  <b>3. Function</b>
  <ul>
    <li>A bloc of reusable code.</li>
    <li>Example:</li>
  </ul>
  <pre>
    <code>
      function greet() {
        return "Hello!";
      }
    </code>
  </pre>
  <p>ðŸ‘‰ All of these (object, array, function) are technically objects in JavaScript.</p>

  <h4>Checking Data Types</h4>
  You can use the <code>typeof</code> operator:

  <pre>
    <code>
      console.log(typeof 42);        // "number"
      console.log(typeof "Aliye");   // "string"
      console.log(typeof true);      // "boolean"
      console.log(typeof undefined); // "undefined"
      console.log(typeof null);      // "object" (this is a well-known JS bug!)
      console.log(typeof Symbol());  // "symbol"
      console.log(typeof 123n);      // "bigint"
      console.log(typeof [1,2,3]);   // "object"
      console.log(typeof {a:1});     // "object"
      console.log(typeof function(){}); // "function"
    </code>
  </pre>
  
  <h1>JavaScript Operators</h1>
  <p>Operators are special symbols that perform operations on values (variables or literals).<br>Example:</p>
  <pre>
    <code>
      let x = 5 + 3;   // + is an operator
      console.log(x);  // 8
    </code>
  </pre>

  <h3>1. Arithmetic Operators (for numbers)</h3>
  <p>Used for basic math.</p>
  <table style="width:40%">
    <tr>
      <th>Operator</th>
      <th>Meaning</th>
      <th>Example</th>
      <th>Result</th>
    </tr>
    <tr>
      <td>+</td>
      <td>Addition</td>
      <td><code>5 + 3</code></td>
      <td><code>8</code></td>
    </tr>
    <tr>
      <td>-</td>
      <td>Subtraction</td>
      <td><code>5 - 3</code></td>
      <td><code>2</code></td>
    </tr>
    <tr>
      <td>*</td>
      <td>Multiplication</td>
      <td><code>5 * 3</code></td>
      <td><code>15</code></td>
    </tr>
    <tr>
      <td>/</td>
      <td>Division</td>
      <td><code>10 / 2</code></td>
      <td><code>5</code></td>
    </tr>
    <tr>
      <td>%</td>
      <td>Modulus (remainder)</td>
      <td><code>10 % 3</code></td>
      <td><code>1</code></td>
    </tr>
    <tr>
      <td>**</td>
      <td>Exponentiation (power)</td>
      <td><code>2 ** 3</code></td>
      <td><code>8</code></td>
    </tr>
    <tr>
      <td>++</td>
      <td>Increment</td>
      <td><code>let a = 5; a++;</code></td>
      <td><code>6</code></td>
    </tr>
    <tr>
      <td>--</td>
      <td>Decrement</td>
      <td><code>let b = 5; b--;</code></td>
      <td><code>4</code></td>
    </tr>
  </table>
  <h3>2. Assignment Operators</h3>
  <p>Used to assign values to variables.</p>
  <table style="width:40%">
    <tr>
      <th>Operator</th>
      <th>Meaning</th>
      <th>Example</th>
      <th>Same as</th>
    </tr>
    <tr>
      <td>=</td>
      <td>Assign</td>
      <td><code>x = 10</code></td>
      <td><code>x = 10</code></td>
    </tr>
    <tr>
      <td>+=</td>
      <td>Add and assign</td>
      <td><code>x += 5</code></td>
      <td><code>x = x + 5</code></td>
    </tr>
    <tr>
      <td>-=</td>
      <td>Subtract and assign</td>
      <td><code>x -= 3</code></td>
      <td><code>x = x - 3</code></td>
    </tr>
    <tr>
      <td>*=</td>
      <td>Multiply and assign</td>
      <td><code>x *= 2</code></td>
      <td><code>x = x * 2</code></td>
    </tr>
    <tr>
      <td>/=</td>
      <td>Divide and assign</td>
      <td><code>x /= 2</code></td>
      <td><code>x = x / 2</code></td>
    </tr>
    <tr>
      <td>%=</td>
      <td>Modulas and assign</td>
      <td><code>x %= 3</code></td>
      <td><code>x = x % 3</code></td>
    </tr>
    <tr>
      <td>**=</td>
      <td>Exponent and assign</td>
      <td><code>x **= 3</code></td>
      <td><code>x = x ** 3 </code></td>
    </tr>
  </table>
  <h3>3. Comparison Operators (return <code>true</code> or <code>false</code>)</h3>
  <p>Used in conditions (like <code>if</code>).</p>
  <table style="width:40%">
    <tr>
      <th>Operator</th>
      <th>Meaning</th>
      <th>Example</th>
      <th>Result</th>
    </tr>
    <tr>
      <td>==</td>
      <td>Equal to (loose)</td>
      <td><code>5 == "5"</code></td>
      <td><code>true</code></td>
    </tr>
    <tr>
      <td>===</td>
      <td>Equal to (strict, checks type)</td>
      <td><code>5 === "5"</code></td>
      <td><code>false</code></td>
    </tr>
    <tr>
      <td>!=</td>
      <td>Not equal (loose)</td>
      <td><code>5 != "5"</code></td>
      <td><code>false</code></td>
    </tr>
    <tr>
      <td>!==</td>
      <td>Not equal (strict)</td>
      <td><code>5 !== "5"</code></td>
      <td><code>true</code></td>
    </tr>
    <tr>
      <td>></td>
      <td>Greater than</td>
      <td><code>8 > 5</code></td>
      <td><code>true</code></td>
    </tr>
    <tr>
      <td><</td>
      <td>Less than</td>
      <td><code>8 < 5</code></td>
      <td><code>false</code></td>
    </tr>
    <tr>
      <td>>=</td>
      <td>Greater or equal</td>
      <td><code>5 >= 5</code></td>
      <td><code>true</code></td>
    </tr>
    <tr>
      <td><=</td>
      <td>Less or equal</td>
      <td><code>5 <= 5</code></td>
      <td><code>true</code></td>
    </tr>
  </table>
  <h3>4. Logical Operators (combine conditions)</h3>
  <p>Work with booleans (<code>true</code> / <code>false</code>)</p>
  <table style="width:40%">
    <tr>
      <th>Operator</th>
      <th>Meaning</th>
      <th>Example</th>
      <th>Result</th>
    </tr>
    <tr>
      <td>&&</td>
      <td>And</td>
      <td><code>true %% false<br>(3 < 10 && 1 > 4)</code></td>
      <td><code>false<br>false</code></td>
    </tr>
    <tr>
      <td>||</td>
      <td>Or</td>
      <td><code>true || false<br>(5 === 5 || 6 === 5)</code></td>
      <td><code>true<br>(true)</code></td>
    </tr>
    <tr>
      <td>!</td>
      <td>Not</td>
      <td><code>!true<br>(!(5 === 5))</code></td>
      <td><code>false<br>false</code></td>
    </tr>
  </table>
  <h3>5. String Operators</h3>
  <p>Only <code>+</code> and <code>+=</code> work fo strings (concatenation).</p>
  <pre>
    <code>
      let first = "Ceren";
      let last = "Josh";
      console.log(first + " " + last); // Ceren Josh
    </code>
  </pre>
  <h3>6. Ternary Operator</h3>
  <p>Shortland for <code>if...else</code>.</p>
  <pre>
    <code>
      let age = 18;
      let canVote = (age >= 18) ? "Yes" : "No";
      console.log(canVote);  // Yes
    </code>
  </pre>
  <h3>7. Type Operators</h3>
  <table style="width:40%;">
    <tr>
      <th>Operator</th>
      <th>Example</th>
      <th>Meaning</th>
    </tr>
    <tr>
      <td><code>typeof</code></td>
      <td><code>typeof "Hello"</code></td>
      <td><code>"string"</code></td>
    </tr>
    <tr>
      <td><code>instanceof</code></td>
      <td><code>x instanceof Array</code></td>
      <td><code>true</code> if x is an array</td>
    </tr>
  </table>
  <h3>What is Operator Precedence?</h3>
  <p>If an expression has more than one operator, JavaScript follows precedence rules.</p>
  
  <h4>Associativity</h4>
  <p>If two operators have the same precedence, then associativity decides the order.</p>
  <li><b>Left-to-right</b> â†’ +, -, *, /, %</li>
  <li><b>Right-to-left</b> â†’ =, **, ternary ?:</li>
  <p>Example:</p>
  <pre>
    <code>
      console.log(2 ** 3 ** 2); // 512, not 64
      // Because ** is right-to-left: 3 ** 2 = 9, then 2 ** 9 = 512
    </code>
  </pre>
  <h4>Common Precedence Order (highest â†’ lowest)</h4>
  <p>Here's a simplified table you can remember:</p>
  <table style="width:40%;">
    <tr>
      <th>Precedence</th>
      <th>Operator(s)</th>
      <th>Associativity</th>
      <th>Example</th>
    </tr>
    <tr>
      <td>20</td>
      <td><code>()</code>(parentheses)</td>
      <td>n/a</td>
      <td><code>(2 + 3) * 4 = 20</code></td>
    </tr>
    <tr>
      <td>19</td>
      <td><code>++</code>, <code>--</code> (postfix)</td>
      <td>left-to-right</td>
      <td><code>x++</code></td>
    </tr>
    <tr>
      <td>17</td>
      <td><code>++</code>, <code>--</code> (prefix), <code>!</code>, <code>typeof</code>, <code>delete</code>, <code>+</code> (unary), <code>-</code> (unary)</td>
      <td>right-to-left</td>
      <td><code>-x</code>, <code>!true</code></td>
    </tr>
    <tr>
      <td>16</td>
      <td><code>**</code> (exponent)</td>
      <td>right-to-left</td>
      <td><code>2 ** 3 ** 2</code></td>
    </tr>
    <tr>
      <td>15</td>
      <td><code>*, /, %</code></td>
      <td>left-to-right</td>
      <td><code>10 / 2 * 3</code></td>
    </tr>
    <tr>
      <td>14</td>
      <td><code>+, -</code></td>
      <td>left-to-right</td>
      <td><code>10 - 5 + 2</code></td>
    </tr>
    <tr>
      <td>13</td>
      <td><code><<, >>, >>></code> (bitwise shifts)</td>
      <td>left-to-right</td>
      <td><code>4 << 1</code></td>
    </tr>
    <tr>
      <td>12</td>
      <td><code><, <=, >, >=</code></td>
      <td>left-to-right</td>
      <td><code>5 > 3</code></td>
    </tr>
    <tr>
      <td>11</td>
      <td><code>==, !=, ===, !==</code></td>
      <td>left-to-right</td>
      <td><code>5 === "5"</code></td>
    </tr>
    <tr>
      <td>10</td>
      <td><code>&</code> (bitwise AND)</td>
      <td>left-to-right</td>
      <td><code>a & b</code></td>
    </tr>
    <tr>
      <td>9</td>
      <td><code>^</code> (bitwise XOR)</td>
      <td>left-to-right</td>
      <td><code>a ^ b</code></td>
    </tr>
    <tr>
      <td>8</td>
      <td><code>|</code> (bitwise OR)</td>
      <td>left-to-right</td>
      <td><code>a | b</code></td>
    </tr>
    <tr>
      <td>7</td>
      <td><code>&&</code> (logical AND)</td>
      <td>left-to-right</td>
      <td><code>true && false</code></td>
    </tr>
    <tr>
      <td>6</td>
      <td><code>||</code> (logical OR)</td>
      <td>left-to-right</td>
      <td><code>true || false</code></td>
    </tr>
    <tr>
      <td>5</td>
      <td><code>?:</code> (ternary)</td>
      <td>right-to-left</td>
      <td><code>age > 18 ? "Yes" : "No"</code></td>
    </tr>
    <tr>
      <td>4</td>
      <td><code>=, +=, -=, *=, ...</code></td>
      <td>right-to-left</td>
      <td><code>x = 5</code></td>
    </tr>
    <tr>
      <td>3</td>
      <td><code>,</code> (comma)</td>
      <td>left-to-right</td>
      <td><code>let x = (1, 2, 3); // 3</code></td>
    </tr>
  </table>
  <h4>Parentheses Override Everything</h4>
  <p>If you're unsure, always use <code>()</code>.</p>
  <pre>
    <code>
      let result = (2 + 3) * 4; // 20
    </code>
  </pre>

  <strong>âœ… In short:</strong>
  <ol>
    <li>Parentheses first.</li>
    <li>Unary operators (++, --, !, typeof).</li>
    <li>Multiplication/Division/Modulus.</li>
    <li>Addition/Subtraction.</li>
    <li>Comparisons.</li>
    <li>Logical (&&, ||).</li>
    <li>Assignment last.</li>
  </ol>

  <h1>String Concatenation</h1>
  <p>String concatenation means joining two or more strings into one string.</p>
  <h4>1. Using the + Operator</h4>
  <p>The most traditional way.</p>
  <pre>
    <code>
      let firstName = "Kevin";
      let lastName = "Swift";

      let fullName = firstName + " " + lastName;
      console.log(fullName); // Kevin Swift
    </code>
  </pre>
  <h4>2. Using the += Operator</h4>
  <p>Appends a string to an existing string.</p>
  <pre>
    <code>
      let message = 'Hello';
      message += 'World!';
      console.log(message); //Hello World!
    </code>
  </pre>
  <h4>3. Using Template Strings (Recommended)</h4>
  <p>Cleaner and more modern (ES6+).</p>
  <pre>
    <code>
      let firstName = "Kevin";
      let lastName = "Swift";

      let fullName = `${firstName} ${lastName}`;
      console.log(fullName); // Kevin Swift
    </code>
  </pre>
  <h4>4. Concatenating Multiple Strings</h4>
  <pre>
    <code>
      let str1 = "Java";
      let str2 = "Script";
      let str3 = " is awesome!";

      let result = str1 + str2 + str3;
      console.log(result); // JavaScript is awesome!
    </code>
  </pre>
  <h4>5. Concatenating with Numbers</h4>
  <p>If one side is a string, numbers will be converted to strings automatically.</p>
  <pre>
    <code>
      let score = 100;
      console.log("Your score is " + score); // "Your score is 100"
    </code>
  </pre>
  <p>Be careful: sometimes this causes unexpected results.</p>
  <pre>
    <code>
      console.log(1 + 2 + "3"); // "33" (not 6)
      console.log("1" + 2 + 3); // "123"
    </code>
  </pre>

  <h1>Template Strings</h1>
  <h4>What are Template Strings</h4>
  <p>Template strings are a way to work with strings in JavaScript that are more powerful and flexible than normal strings.<br>They use <b>backticks (`) instead of quotes (' or ").</b></p>

  <h4>Key Features</h4>
  <h5>1. String Interpolation (insert variables direclty)</h5>
  <p>Instead of using + for concatenation, you can insert variables with <b>${ }.</b></p>
  <pre>
    <code>
      let name = "Fatma";
      let age = 18;

      let intro = `My name is ${name} and I am ${age} years old.`;
      console.log(intro);
      //My name is Fatma and I am 18 years old.
    </code>
  </pre>
  <h5>2. Multi-line Strings</h5>
  <p>You can write strings across multiple lines without using <b>\n</b>.</p>
  <pre>
    <code>
      let message = `Hello,
      This is a Multi-line
      string in JS.`;

      console.log(message);
      /*
      Hello,
      This is a Multi-line
      string in JS.
      */
    </code>
  </pre>
  <h5>3. Expression Embedding</h5>
  <p>You can put any JavaScript expression inside <b>${}</b>.</p>
  <pre>
    <code>
      let a = 10;
      let b = 20;

      console.log(`The sum is ${a + b}`);  // The sum is 30
      console.log(`Next year: ${new Date().getFullYear() + 1}`);
    </code>
  </pre>
  <h5>4. Function Calls </h5>
  <p>You can even call functions inside <b>${}</b>.</p>
  <pre>
    <code>
      function greet(name) {
        return `Hello, ${name}!`;
      }

      console.log(`${greet("Fatma")}`); //Hello, Fatma
    </code>
  </pre>

  <h5>5. Tagged Templates (advanced)</h5>
  <p>Special functions can process template literals.<br>(Useful for libraries like GraphQL, styled-components in React, etc.)</p>
  <pre>
    <code>
      function tag(strings, value) {
        return strings[0] +  value.toUpperCase();
      }

      let name = 'Fatma';
      console.log(tag`Hello ${name}`); // Hello FATMA
    </code>
  </pre>
  <p><b>Quick Summary</b></p>
  <ul>
    <li>
      <b>Normal string:</b><code>"My name is " + name + " and I am " + age + " years old."</code>
    </li>
    <li>
      <b>Template string:</b><code>`My name is ${name} and I am ${age} years old.`</code> âœ… cleaner!
    </li>
  </ul>

  <h1>Type Conversion (Explicit)</h1>
  <p>You manually convert a value from one type to another. Also called <b>type casting</b>.<br>Examples:</p>
  <pre>
    <code>
      // String â†’ Number
      let num1 = Number("42");
      console.log(num1); // 42 (number)

      // Number â†’ String
      let str1 = String(42);
      console.log(str1); // "42"

      // Boolean â†’ Number
      console.log(Number(true));  // 1
      console.log(Number(false)); // 0
    </code>
  </pre>
  <p>You explicitly use functions like:</p>
  <ul>
    <code>
      <li>Number(value)</li>
      <li>String(value)</li>
      <li>Boolean(value)</li>
      <li>parseInt(value)</li>
      <li>parseFloat(value)</li>
    </code>
  </ul>

  <h1>Type Coercion (Implicit)</h1>
  <p>JavaScript automatically converts a values's type when needed. This happens behind the scenes.<br>Examples:</p>
  <pre>
    <code>
      console.log("5" + 2); // "52" (number 2 coerced to string)
      console.log("5" - 2); // 3 (string "5" coerced to number)
      console.log("5" * "2") // 10 (both coerced to numbers)
      console.log("Mark" * 3); // NaN (not a number)
    </code>
  </pre>
  <p>Coercion can be tricky because sometimes results are unexpected.</p>
  <h2>Type Conversion vs Type Coercion</h2>
  <table>
    <tr>
      <th>Feature</th>
      <th>Type Conversion (Explicit)</th>
      <th>Type Coercion (Implicit)</th>
    </tr>
    <tr>
      <td>Who decides?</td>
      <td>The programmer</td>
      <td>JavaScript engine</td>
    </tr>
    <tr>
      <td>How?</td>
      <td>By using <code>Number()</code>, <code>String()</code>, etc.</td>
      <td>By context (+, -, *, ==, etc.)</td>
    </tr>
    <tr>
      <td>Example</td>
      <td><code>Number("123") â†’ 123</code></td>
      <td><code>"123" - 0 â†’ 123</code></td>
    </tr>
  </table>

  <h1>If Statement in JavaScript</h1>
  <p>The <code>if</code> statement is a conditional statement.<br>It allows your program to make decisions:<br>ðŸ‘‰ "If a condition is true, do something. Otherwise, skip it."</p>

  <p><b>Syntax:</b></p>
  <pre>
    <code>
      if (condition) {
        // code to run if condition is true
      }
    </code>
  </pre>
  <ul>
    <li><code>condition</code> â†’ must be a boolean (<code>true</code> or <code>false</code>).</li>
    <li>If <code>condition</code> is <code>true</code> â†’ the code inside <code>{ }</code> runs.</li>
    <li>If <code>condition</code> is <code>false</code> â†’ the code inside <code>{ }</code> is skipped.</li> 
  </ul>
  <p>Example 1</p>
  <pre>
    <code>
      let age = 20;

      if (age >= 18) {
        console.log("You are an adult.");
      }
    </code>
  </pre>
  <p>Example 1</p>
  <pre>
    <code>
      let age = 20;

      if (age >= 18) {
        console.log("You are an adult.");
      }
    </code>
  </pre>
  <p>âœ” Output: <code>You're an adult.</code> (because <code>20 >= 18</code> is <code>true</code>)</p>
  <p>Example 2</p>
  <pre>
    <code>
      let age = 15;

      if (age >= 18) {
        console.log("You are an adult.");
      }
    </code>
  </pre>
  <p>âœ” Output: (nothing) because <code>15 >= 18</code> is false.</p>
  <h3>With <code>else</code></h3>
  <p>You can add <code>else</code> for when the condition is <code>false</code>:</p>
  <pre>
    <code>
      let age = 15;

      if (age >= 18) {
        console.log("You are an adult.");
      } else {
        console.log("You are under 18.");
      }
    </code>
  </pre>
  <p>âœ” Output: <code>You are under 18.</code></p>
  <h3>With <code>else if</code> (multiple conditions)</h3>
  <pre>
    <code>
      let score = 75;

      if (score >= 90) {
        console.log("Grade: A")
      } else if (score >= 70) {
        console.log("Grade: B");
      } else {
        console.log("Grade: C or lower");
      }
    </code>
  </pre> 
  <p>âœ” Output: <code>Grade: B</code></p>
  <p>ðŸ‘‰ In short:</p>
  <ul>
    <li><code>if</code> â†’ checks condition.</li>
    <li><code>else</code> â†’ runs if condition is false.</li>
    <li><code>else if</code> â†’ lets you check multiple conditions.</li>
  </ul>

  <h1>Truthy and Falsy Values</h1>
  <p>When JavaScript expects a boolean (<code>true</code> or <code>false</code>) but gets a non-boolean value, it automatically converts the value to either truthy or falsy.<br>This usually happens in conditions like <code>if</code>, loops, or logical operators.</p>
  <h3>Falsy Values</h3>
  <p>In JavaScript, only 6 values are considered falsy:</p>
  <ol>
    <li><code>false</code></li>
    <li><code> (zero)</code></li>
    <li><code>""</code> (empty string)</li>
    <li><code>null</code></li>
    <li><code>undefined</code></li>
    <li><code>NaN</code> (Not-a-number)</li>
  </ol>

  <h3>Truthy Values</h3>
  <p>Everything other than falsy values is truthy.<br>Examples:</p>
  <ul>
    <li><code>true</code></li>
    <li>Any non-zero number (<code>1, -5, 3.14</code>)</li>
    <li>Any non-empty string (<code>"hello", "0", "false"</code>)</li>
    <li>Objects(<code>{}, [], function() {}</code>)</li>
  </ul>
  <p>Example in Code</p>
  <pre>
    <code>
      if ("hello") {
        console.log("This is truthy!"); 
      }
      // Output: This is truthy!

      if (0) {
        console.log("This is truthy!");
      } else {
        console.log("This is falsy!");
      }
      // Output: This is falsy!
    </code>
  </pre>
  <pre>
    <code>
      console.log(Boolean(""));   // false
      console.log(Boolean("hi")); // true
      console.log(Boolean(0));    // false
      console.log(Boolean(42));   // true
    </code>
  </pre>

  <h1>Equality Operators</h1>
  <h3>1. Loose Equality (<code>==</code>)</h3>
  <ul>
    <li>Compares two values after converting (coercing) them to the same type.</li>
    <li>It does not check data type strictly.</li>
  </ul>
  <pre>
    <code>
      5 == "5";   //true (string "5" is converted to number)
      0 == false; //true (false is converted to 0)
      null == undefined; //true
    </code>
  </pre>
  <h3>2. Strictly Equality (===)</h3>
  <ul>
    <li>Compares two values without type conversion.</li>
    <li>Both value and type must be the same.</li>
  </ul>
  <p>Example:</p>
  <pre>
    <code>
      5 === "5";  //false (different types: number vs string)
      0 === false //false (number vs boolean)
      5 === 5 //true (same type and value)
    </code>
  </pre>
  <h3>3. Inequality Operators</h3>
  <ul>
    <li><code>!=</code> â†’ Loose inequality (does type conversion).</li>
    <li><code>!==</code> â†’ Strict inequality (no type conversion)</li>
  </ul>
  <p>Example:</p>
  <pre>
    <code>
      5 != "5";  //false (after coercion, 5 == 5)
      5 !== "5"  //true (different types)
    </code>
  </pre>

  <p><b>âš¡ Quick Summary</b></p>
  <ul>
    <li><code>==</code> â†’ equality with type coercion</li>
    <li><code>===</code> â†’ equality without type coercion (recommended)</li>
    <li><code>!=</code> â†’ inequality with type coercion</li>
    <li><code>!==</code> â†’ inequality without type coercion</li>
  </ul>
  <p>Best practice: Always use === and !== to avoid unexpected results.</p>
  
  <h1>Boolean Logic and Logical Operators</h1>
  <p>Boolean logic is a way of reasoning with true and false values using logical operators.<br>It's widely used in programming for decision-making (like in <code>if</code> statements).</p>
  <p>Logical operators are used to combine or manipulate boolean values (<code>true</code> or <code>false</code>) and return a boolean result.</p>
  <p>The three main boolean operators:</p>
  <h3>1. AND (&&)</h3>
  <p>Returns <code>true</code> if both conditions are true</p>
  <pre><code>
    console.log(true && true);  //true
    console.log(true && false); //false
    console.log(false && false); //false
  </code></pre>
  <p>Example:</p>
  <pre>
    <code>
      let age = 20;
      if (age >= 18 && age < 30) {
        console.log("You are a young adult.")
      }
      // Both conditions must be true
    </code>
  </pre>
  <h3>OR (||)</h3>
  <p>Returns <code>true</code> if at least one condition is true.</p>
  <pre>
    <code>
      console.log(true || false);  //true
      console.log(false || false);  //true
    </code>
  </pre>
  <p>Example:</p>
  <pre>
    <code>
      let day = "Saturday";
      if (day === "Saturday" || day === "Sunday") {
        console.log("It's the weekend!");
      }
      // Only one condition needs to be true
    </code>
  </pre>
  <h3>NOT (!)</h3>
  <p>Reverses a value: true â†’ false, false â†’ true.</p>
  <pre><code>
    console.log(!true);  //false
    console.log(!false);  //true
  </code></pre>
  <p>Example:</p>
  <pre>
    <code>
      let isLoggedIn = false;
      if (!isLoggedIn) {
        console.log("Please log in.");
      }
    </code>
  </pre>
  <h1><code>switch</code> Statement</h1>
  <p>A switch statement is used when you want to compare one value against many possible cases.<br>Instead of writing a long chain of <code>if ... else if ... else</code>, you can use <code>switch</code> for cleaer code.</p>
  <p>Syntax</p>
  <pre>
    <code>
      switch (expression) {
        case value1:
          // code block if expression === value1
          break;
        case valeu2:
          // code block if expression === valeu2
          break;
        default:
          // code block if no case matches
      }
    </code>
  </pre>
  <p>How it works</p>
  <ol>
    <li>JavaScript evaluates the expressions.</li>
    <li>It checks each case one by one.</li>
    <li>If it finds a match (=== strict equality), it runs that block.</li>
    <li>The <code>break</code> keyword stops execution, so the program doesn't continue to the next case.</li>
    <li>If no match is found, the <code>default</code> block runs.</li>
  </ol>
  <p>Example:</p>
  <pre>
    <code>
      const day = 'friday';

      switch (day) {
        case 'monday': // day === 'monday'
          console.log('Plan course structure');
          console.log('Go to coding meetup');
          break;
        case 'tuesday':
          console.log('Prepare theory videos');
          break;
        case 'wednesday':
        case 'thursday':
          console.log('Write code examples');
          break;
        case 'friday':
          console.log('Record videos');
          break;
        case 'saturday':
        case 'sunday':
          console.log('Enjoy the weekend :D');
          break;
        default:
          console.log('Not a valid day!');
      }
    </code>
  </pre>
  <h1>Expression vs. Statement</h1>
  <h3>Expression</h3>
  <p>An expression is a piece of code that produces a value.<br>It can be as simple as a single value (like a number) or as complex as a combination of variables, operators, and functions.<br>Examples:</p>
  <pre>
    <code>
      // Simple expressions (just values):
      5         // produces 5
      "Hello"   // produces "Hello"
      true      // produces true 

      // Arithmetic expressions:
      2 + 3     // produces 5
      10 * 1    // produces 10
      
      // String expressions:
      "App" + "le"  // produces "Apple"

      // Variable expressions:
      let x = 7;
      x + 3;  // produces 10

      // Function expressions:
      Math.sqrt(16);   // produces 4
    </code>
  </pre>
  <h3>Statement</h3>
  <p>A statement is an instruction that tells JavaScript to perform an action.<br>It's like a compelete sentence in a programming language.<br>Examples of statements:</p>
  <pre>
    <code>
      let x = 5;     // variable declaration statement
      if (x > 0) {   // if statement
        console.log("Positive number");  // expression statement inside
      }

      // Declaration statements - define variables or functions
      let name = "Delta";
      function greet() { console.log("Hello"); }

      // Control flow statements - control execution
      if (age > 18) { ... }
      else { ... }
      switch (day) { ... }

      // Looping statements - repeat actions
      for (let i = 0; i < 5; i++) { ... }
      while (x < 10) { ... }

      // Expression statements - expressions used as standalone instructions
      x + 5;              // valid but useless statement
      console.log(x);     // function call as a statement
    </code>
  </pre>  
  <p><b>Characteristics of Statements</b></p>
  <ul>
    <li>They do something but don't always return a value.</li>
    <li>End with a semicolon (;) (except block statements).</li>
    <li>They can contain expressions inside them.</li>
  </ul>
  <p><b>Key difference</b></p>
  <ul>
    <li>Expression â†’ produces a value.</li>
    <li>Statement â†’ performs an action.</li>
  </ul>
  <p>Example mixing both:</p>
  <pre><code>
    let age = 23;               // statement
    let isAdult = age >= 18;    // expression inside a statement
  </code></pre>
  <ul>
    <li><code>age >= 18</code> is an expression â†’ produces <code>true</code></li>
    <li><code>let isAdult = age >= 18;</code> is a statement â†’ assigns that value to <code>isAdult</code>.</li>
  </ul>
  <p><b>Quick Tip to Remember</b></p>
  <ul>
    <li>If you can print it or use it in another expression, it's an expression.</li>
    <li>If it's an instruction to do something, it's a statement.</li>
  </ul>
  <h1>The Conditional (Ternary) Operator (? :) in JavaScript</h1>
  <p>The ternary operator is a shorthand way of writing an if...else statement in a single line.<br>It is called "ternary" because it takes three operands:<br>Syntax:</p>
  <code>condition ? expressionIfTrue : expressionIfFalse</code>
  <ul>
    <li>condition â†’ A boolean expression that is evaluated (true or false).</li>
    <li>expressionIfTrue â†’ Runs if the condition is true.</li>
    <li>expressionIfFalse â†’ Runs if the condition is false.</li>
  </ul>
  <p>Example 1: Basic</p>
  <pre>
    <code>
      let age 18;
      let canVote = age >= 18 ? "Yes, you can vote" : "No, you cannot vote";
      
      console.log(canVote);
      // Output: Yes, you can vote
    </code>
  </pre>
  <p>Equivalent if...else:</p>
  <pre>
    <code>
      let age = 18;
      let canVote;

      if (age >= 18) {
        canVote = "Yes, you can vote";
      } else {
        canVote = "No, you cannot vote";
      }
    </code>
  </pre>
  <p>Example 2: Nested Ternary (not always recommended, can get confusing)</p>
  <pre>
    <code>
      let score = 85;

      let grade = score >= 90 ? "A" :
                  score >= 70 ? "B" :
                  score >= 60 ? "C" : "F";
      
      console.log(grade);
      // Output: B
    </code>
  </pre>
  <p>Example 3: Using in console.log directly</p>
  <pre>
    <code>
      let isMember = false;

      console.log(isMember ? "Welcome back, member!" : "Please sign up.");
      // Output: Please sign up.
    </code>
  </pre>
  <h1>Strict Mode</h1>
  <p>Strict mode is a special mode in JavaSript that makes the language more strict and secure.<br>It helps you write cleaner, less error-prone code by catching mistakes that are normally ignored.</p>
  <h4>How to Enable Strict Mode?</h4>
  <p>Add this line at the top of your script or function:</p>
  <pre><code>
    "use strict";
  </code></pre>
  <p>Example (global strict mode):</p>
  <pre><code>
    "use strict";

    x = 10;    // Error: x is not declared
  </code></pre>
  <p>Example (strict mode only in a function):</p>
  <pre><code>
    function myFunction() {
      "use strict";
      y = 5;     // Error inside this function
    }
  </code></pre>
  <h4>What Strict Mode Does</h4>
  <p>1. Prevents using undeclared variables</p>
  <pre><code>
    "use strict";
    x = 3.14;   // ReferenceError
  </code></pre>
  <p>2. Disallows deleting variables or functions</p>
  <pre><code>
    "use strict";
    let a = 5;
    delete a;  // SyntaxError
  </code></pre>
  <p>3. Catches dulicate parameter names</p>
  <pre><code>
    "use strict";
    function sum(a, a)  {  // SyntaxError
      return a + a;
    }
  </code></pre>
  <p>4. Make <code>this</code> safer</p>
  <ul>
    <li>In normal mode: <code>this</code> inside a function defaults to the global object (<code>window</code> in browsers).</li>
    <li>In strict mode: <code>this</code> becomes <code>undefined</code> if not explicitly set.</li>
  </ul>
  <pre><code>
    "use strict";
    function test() {
      console.log(this);  // undefined
    }
    test();
  </code></pre>
  <p>5. Reserved keywords are protected</p>
  <pre><code>
    "use strict";
    let public = 123;   // SyntaxError (future reserved keyword)
  </code></pre>

  <h1>Functions</h1>
  <p>A function is a block of code designed to perform a specific task.<br>You can define it once and then reuse it many times.</p>
  <p>The simplest form of a function is a <b>function declaration:</b></p>
  <pre><code>
    function logger() {
      console.log('My name is Aliye!');
    }

    // Calling/running/invoking the function
    logger();
    logger();
  </code></pre>
  <p>Functions can receive input data (parameters) and return output data:</p>
  <pre><code>
    function fruitProcessor(apples, oranges) {
      console.log(apples, oranges);
      const juice = `Juice with ${apples} apples and ${oranges} oranges.`;
      return juice;
    }
    
    // Using the function with arguments 5 and 0
    const appleJuice = fruitProcessor(5, 0);
    console.log(appleJuice);
    
    // Reusing the function with different inputs
    const appleOrangeJuice = fruitProcessor(2, 4);
    console.log(appleOrangeJuice);
  </code></pre>
  <p>In this example:</p>
  <ul>
    <li>apples and oranges are parameters (placeholders)</li>
    <li>5, 0, 2, and 4 are arguments (actual values)</li>
    <li>The function processes these inputs and returns a string</li>
  </ul>
  <p>Functions help us write DRY code (Don't Repeat Yourself), which is an important clean code principle.</p>
  <h2>Function Declarations</h2>
  <p>A function declaration is the standard way to define a function in JavaScript.<br>It uses the <code>function</code> keyword, followed by a name, optional parameters, and a body.</p>
  <pre><code>
    // Function Declaration:

    function calcAge1(birthYear) {
      return 2025 - birthYear;
    }

    const age1 = calcAge1(1990);
  </code></pre>
  <h4>Key Features of Function Declarations</h4>
  <h5>1. Named Functions</h5>
  <ul><li>Every function declaration must have a name.</li></ul>
  <pre><code>
    function add(a, b) {
      return a + b;
    }
  </code></pre>
  <h5>2. Hoisting</h5>
  <ul>
    <li>Function declarations are hoisted to the top of their scope.</li>
    <li>This means you can call them before they are defined in the code.</li>
  </ul>
  <pre><code>
    sayHi();   // Works, output: Hi!

    function sayHi() {
      console.log("Hi!");
    }
  </code></pre>
  <h5>3. Reusable</h5>
  <ul><li>You can call the same function as many times as you want with different arguments.</li></ul>
  <pre><code>
    function square(n) {
      return n * n;
    }

    console.log(square(4));  // 16
    console.log(square(7));  // 49
  </code></pre>
  <h4>When to Use</h4>
  <ul>
    <li>Use function declarations when you want your function to be available everywhere in its scope, even before it's written in the code.</li>
    <li>They're good for main tasks in your program that you'll call often.</li>
  </ul>
  <p><b>Summary:</b> A function declaration defines a named function using the <code>function</code> keyword. It is hoisted, reusable, and can be called anywhere in its scope.</p>
  <h2>Function Expression:</h2>
  <p>A function expression means creating a function and assigning it to a variable.<br>Unlike function declarations, it is not hoisted, so you must define it before using it.</p>
  <pre><code>
    // Function Expression:

    const calcAge2 = function (birthYear) {
      return 2025 -birthYear;
    }

    const age2 = calcAge2(1990);
    console.log(age1, age2);   // Both produce the same result
  </code></pre>
  <h4>Key Features of function Expressions</h4>
  <h5>1. Anonymous or Named</h5>
  <ul><li>Anonymous function (most common):</li></ul>
  <pre><code>
    const add = function(a, b) {
      return a + b;
    }
  </code></pre>
  <ul><li>Named function expression (rare but useful for debugging):</li></ul>
  <h5>2. Not Hoisted</h5>
  <ul><li>You cannot call a function expression before it's defined.</li></ul>
  <pre><code>
    sayHi();  // Error: cannot access 'sayHi' before initialization

    const sayHi = function() {
      console.log("Hi!");
    }
  </code></pre>
  <h5>3. Stored in Variables</h5>
  <ul><li>Since the function is stored in a variable, you can pass it around like data.</li></ul>
  <pre><code>
    const square = function(n) {
      return n * n;
    }

    const numbers = [2, 4, 6];
    const results = numbers.map(square);   // [4, 16, 36]
  </code></pre>
  <h4>When to Use</h4>
  <ul>
    <li>When you need a function only after it's defined.</li>
    <li>When you want to assign functions to variables, objects, or pass them as arguments (very common in callbacks and functional programming).</li>
  </ul>
  <p><b>Summary:</b> A function expression creates a function and assigns it to a variable. Unlike declarations, it is not hoisted. It can be anonymous or named, and is commonly used for callbacks and passing functions around.</p>

  <p><b>Function Declaration vs. Expressions:</b> The main difference between them is that function declarations can be called before they're defined in the code (due to a process called hoisting), while function expressions cannot:</p>
  <pre><code>
    // This works
    const age1 = calcAge1(1991);
    
    function calcAge1(birthYear) {
      return 2037 - birthYear;
    }
    
    // This would cause an error if placed before the function expression
    const age2 = calcAge2(1991);
    
    const calcAge2 = function (birthYear) {
      return 2037 - birthYear;
    };
  </code></pre>
  <p>Both have their place in JavaScript, and which one you use often comes down to personal preference.</p>
  <h1>Arrow Function</h1>
  <p>An arrow function is a shorter way to write function expressions, especially useful for simple one-line functions, introduced in ES6(2015).<br>It uses the <code>=></code> (arrow) syntax.</p>
  <pre><code>
    // Arrow function with one parameter and implicit return
    const calcAge3 = birthYear => 2025 - birthYear;
    const age3 = calcAge3(1990);
    console.log(age3);

    // Arrow function with multiple parameters and multiple lines of code
    const yearsUntilRetirement = (birthYear, firstName) => {
      const age = 2025 - birthYear;
      const retirement = 65 - age;
      return `${firstName} retires in ${retirement} years!`;
    }
    console.log(yearsUntilRetirement(1990, 'Jone'));
  </code></pre>
  <p><b>Key points about arrow functions:</b></p>
  <ol>
    <li>For one parameter and one-line body, you can omit parantheses around parameters and curly braces</li>
    <li>With a one-liner without curly braces, the return is implicit</li>
    <li>For multiple parameters, you need parantheses: (param1, param2) => expression</li>
    <li>For multiple lines of code, you need curly braces and an explicit return statement</li>
    <li>Arrow functions don't have their own <b>this</b> keyword (important for more advanced JavaScript)</li>
  </ol>
  <p><b>No <code>this</code> binding</b></p>
  <ul>
    <li>Arrow functions do not create their own <code>this</code>.</li>
    <li>They use the <code>this</code> value from their surrounding scope.</li>
  </ul>
  <pre><code>
    const person = {
      name: "Aliye",
      greet: function() {
        const inner = () => {
          console.log("Hi, I'm " + this.name);
        }
        inner();
      }
    }
    person.greet();  // Hi, I'm Aliye
  </code></pre>
  <p>With a normal function inside, <code>this</code> would be <code>undefined</code> or the global object.</p>
  <h4>When to Use</h4>
  <ul>
    <li>Great for small, quick functions.</li>
    <li>Perfect for callbacks (e.g., <code>.map(), .filter(), .forEach()</code>).</li>
    <li>Useful when you want to preserve the <code>this</code> value from the surrounding scope.</li>
  </ul>
  <p><b>Summary:</b> Arrow functions are a shorter syntax for function expressions, with differences in <code>this</code> handling, no <code>arguments</code> object, and not usable as constructors.</p>
  <h2>Functions Calling Other Functions</h2>
  <p>In JavaScript, it's common for one function to call another function. This allows us to break down complex problems into smaller, reusable parts.</p>
  <pre><code>
    // Function to cut fruit into pieces
    const cutPieces = function (fruit) {
      return fruit * 4;
    };
    
    // Function that uses the cutPieces function
    const fruitProcessor = function (apples, oranges) {
      const applePieces = cutPieces(apples);
      const orangePieces = cutPieces(oranges);
    
      const juice = `Juice with ${applePieces} pieces of apple and
    ${orangePieces} pieces of orange.`;
      return juice;
    };

    console.log(fruitProcessor(2, 3));
  </code></pre>
  <p>In this example, the fruitProcessor function calls the cutPieces function twice. This approach follows the DRY principle - if we later need to change how fruits are cut (e.g., cut into 3 pieces instead of 4), we only need to change it in one place.</p>

  <h2>Reviewing Functions</h2>
  <pre><code>
    const calcAge = function (birthYear) {
      return 2037 - birthYear;
    };
    
    const yearsUntilRetirement = function (birthYear, firstName) {
      const age = calcAge(birthYear);
      const retirement = 65 - age;
      
      if (retirement >= 0) {
        return `${firstName} retires in ${retirement} years!`;
      } else {
      return `${firstName} is already retired ðŸŽ‰ `;
      }
    };

    console.log(yearsUntilRetirement(1991, 'Jonas'));
    console.log(yearsUntilRetirement(1969, 'Mark'));
  </code></pre>
  <p>Important points about functions:</p>
  <ol>
    <li> Functions can call other functions (like calcAge inside yearsUntilRetirement)</li>
    <li> Parameters are like local variables that only exist inside the function</li>
    <li>Functions with the same parameter names don't interfere with each other</li>
    <li>The return statement immediately exits the function - any code after it won't run</li>
    <li> Functions can return different values based on conditions (like our retirement example)</li>
    <li> Functions can be stored as values and accessed through the console</li>
  </ol>
  <p>Functions are fundamental in JavaScript and understanding them well is critical for becoming proficient.</p>

  <h1>Arrays</h1>
  <p>An array is a special type of object in JavaScript used to store multiple values in a single variable.</p>
  <ul>
    <li>Each values has an index (position number).</li>
    <li>Indexes start at 0.</li>
  </ul>
  <p><b>Syntax</b></p>
  <pre><code>
    // Using array literal (common way)
    const fruits = ["Apple", "Banana", "Orange"];

    // Using new Array() (less common)
    const numbers = new Array(1, 2, 3, 4, 5);
  </code></pre>
  <p>Example</p>
  <pre><code>
    const friends = ["Michael", "Steven", "Peter"];

    console.log(friends[0]);  // Michael
    console.log(friends[2]);  // Peter
    console.log(friends.length);  // 3
    console.log(friends[friends.length - 1]);  // Peter (Last element)
  </code></pre>
  <h3>Array Features</h3>
  <p>Can store different data types:</p>
  <pre><code>
    const mixed = ["Sarah", "37", true, { job: "developer" }];
  </code></pre>
  <p><b>Mutable</b> â†’ You can change values:</p>
  <pre><code>
    const colors = ["Red", "Blue", "Green"];
    colors[1] = "Yellow";
    console.log(colors);  // ["Red", "Yellow", "Green"]
  </code></pre>
  <h3>Common Array Methods</h3>
  <h4>1. Add & Remove</h4>
  <pre><code>
    const friends = ["Sarah", "Steven", "Peter"];

    friends.push("Joy");   // Add to End
    friends.unshift("John")  // Add to start
    console.log(friends)   // ["John", "Sarah", "Steven", "Peter", "Joy"]

    friends.pop();  // Remove last
    friends.shift();  // Remove first
    console.log(friends);   // ["Sarah", "Steven", "Peter"]
  </code></pre>
  <h4>2. Search</h4>
  <pre><code>
    console.log(friends.indexOf("Steven"));  // 1
    console.log(friends.includes("Peter"));  // true
    console.log(includes("Bob"));  // false
  </code></pre>
  <h4>3. Loop through array</h4>
  <pre><code>
    for (let i = 0; i < friends.length; i++) {
      console.log(friends[i]);
    }
  </code></pre>
  <h4>4. Modern Methods</h4>
  <pre><code>
    const numbers = [1, 2, 3, 4, 5];

    console.log(numbers.map(n => n * 2));    // [2, 4, 6, 8, 10]
    console.log(numbers.filter(n => n > 2));  // [3, 4, 5]
    console.log(numbers.reduce((a, b) => a + b, 0));  // 15
  </code></pre>
  <h3>Why Arrays?</h3>
  <ul>
    <li>Store multiple related values together.</li>
    <li>Easy to access and manipulate data.</li>
    <li>Useful for loops, collections, and data processing.</li>
  </ul>
  <p><b>Summary:</b> An array is a collection of values stored under one variable, accessed by index (starting at 0). Arrays are mutable and come with powerful built-in methods like <code>push()</code>, <code>pop()</code>, <code>map()</code>, and <code>filter()</code>.</p>


</body>
</html>